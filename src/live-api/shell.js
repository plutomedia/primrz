/*
pliny.function({
  parent: "Live API",
  name: "shell",
  parameters: [{
    name: "radius",
    type: "Number",
    description: "How far the sphere should extend away from a center point."
  }, {
    name: "widthSegments",
    type: "Number",
    description: "The number of faces wide in which to slice the geometry."
  }, {
    name: "heightSegments",
    type: "Number",
    description: "The number of faces tall in which to slice the geometry."
  }, {
    name: "phi",
    type: "Number",
    optional: true,
    description: "The angle in radians around the Y-axis of the sphere.",
    default: "80 degrees."
  }, {
    name: "theta",
    type: "Number",
    optional: true,
    description: "The angle in radians around the Z-axis of the sphere.",
    default: "48 degrees."
  }],
  description: "The shell is basically an inside-out sphere. Say you want a to model\n\
the sky as a sphere, or the inside of a helmet. You don't care anything about the\n\
outside of this sphere, only the inside. You would use InsideSphereGeometry in this\n\
case. It is mostly an alias for [`InsideSphereGeometry`](#LiveAPI_InsideSphereGeometry).",
  examples: [{
    name: "Create a sky sphere",
    description: "To create a sphere that hovers around the user at a\n\
far distance, showing a sky of some kind, you can use the `shell()` function in\n\
combination with the [`textured()`](#LiveAPI_textured) function. Assuming you have an image\n\
file to use as the texture, execute code as such:\n\
\n\
    grammar(\"JavaScript\");\n\
    var sky = textured(\n\
      shell(\n\
          // The radius value should be less than your draw distance.\n\
          1000,\n\
          // The number of slices defines how smooth the sphere will be in the\n\
          // horizontal direction. Think of it like lines of longitude.\n\
          18,\n\
          // The number of rings defines how smooth the sphere will be in the\n\
          // vertical direction. Think of it like lines of latitude.\n\
          9,\n\
          // The phi angle is the number or radians around the 'belt' of the sphere\n\
          // to sweep out the geometry. To make a full circle, you'll need 2 * PI\n\
          // radians.\n\
          Math.PI * 2,\n\
          // The theta angle is the number of radians above and below the 'belt'\n\
          // of the sphere to sweep out the geometry. Since the belt sweeps a full\n\
          // 360 degrees, theta only needs to sweep a half circle, or PI radians.\n\
          Math.PI ),\n\
      // Specify the texture image next.\n\
      \"skyTexture.jpg\",\n\
      // Specify that the material should be shadeless, i.e. no shadows. This\n\
      // works best for skymaps.\n\
      {unshaded: true} );"
  }]
});
*/

import { cache } from "../util";

import InsideSphereGeometry from "../Primrose/Graphics/InsideSphereGeometry";
import fixGeometry from "../Primrose/Graphics/fixGeometry";


const SLICE = 0.45;

export default function shell(r, slices, rings, phi, theta, options) {
  if (phi === undefined) {
    phi = Math.PI * SLICE;
  }
  if (theta === undefined) {
    theta = Math.PI * SLICE * 0.6;
  }
  var phiStart = 1.5 * Math.PI - phi * 0.5,
    thetaStart = (Math.PI - theta) * 0.5;
  options = options || {};
  return cache(
    `InsideSphereGeometry(${r}, ${slices}, ${rings}, ${phi}, ${theta})`,
    () => fixGeometry(new InsideSphereGeometry(r, slices, rings, phiStart, phi, thetaStart, theta, true), options));
};
