extends ../templates/documentation.pug

block header
  h1 Using the VR Development Environment

block document
  p Primrose is not just a web development framework. It also provides a virtual reality, live-programming environment for rapid prototyping and exploratory programming. You can try out the #[a(href= fileRoot + "doc/editorVR.html") VR Editor] now.

  blockquote
    | NOTE: there are two separate interaction modes in the VR Editor. You switch between these modes by clicking on different objects in the environment:
    ul
      li Navigation Mode - mouse clicks and keyboard events move your body around the environment.
      li Editing Mode - mouse clicks and keyboard events edit text within the Code Editor, but do not cause changes in your body's location.

  h2 Dev Zone Layout

  p Off the bat, there are three text areas visible at approximately arm's distance. We call this the "Dev Zone". It contains the interfaces you will use to read documentation, write code, and see debugging output as you work.

  blockquote You may reset your view to return to the center of the Dev Zone and zero your headset's position and orientation sensors by hitting the #[kbd Z] key on your keyboard.

  h3 Writing in the Code Editor

  p The VR Editor starts in a blank space with a small demo script already loaded in the editor. The center text area is the code editor. It is rendered on the inside of a portion of a sphere, what we call a "shell". Rendering the code to the inside of a sphere means that all points of the editor will be equidistant from your viewing point when you are standing in front of the editor, helping to reduce distortion and make for a more comfortable reading experience.

  blockquote You may reset the editor and reload the original demo code at any time by hitting #[kbd CTRL+SHIFT+X] on Windows/Linux or #[kbd CMD+SHIFT+X] on OS X.

  p Editing text in the Code Editor supports most of the common keyboard shortcuts that you have grown accustomed to in other text editors:
  ul
    li #[kbd Arrow keys] to move around.
    li #[kbd CTRL+Left/Right Arrow keys] on Windows/Linux, or #[kbd ALT+Left/Right Arrow keys] on OS X to skip backwards/forwards by tokens.
    li #[kbd CTRL+Up/Down Arrow keys] on Windows/Linux to scroll the document window without moving the text cursor (not supported on OS X).
    li #[kbd Page Up/Page Down] to move by whole screens of text.
    li #[kbd Home/End] on Windows/Linux, or #[kbd CMD+Left Arrow/Right Arrow key] to jump to the beginning or end of a line of text.
    li #[kbd CTRL+Home/End] on Windows/Linux, or #[kbd CMD+Up Arrow/Down Arrow key] to jump to the beginning or end of the document.
    li #[kbd SHIFT] plus one of the movement commands above to select text.
    li #[kbd CTRL+A] on Windows/Linux or #[kbd CMD+A] on OS X to select all text.
    li #[kbd CTRL+C] on Windows/Linux or #[kbd CMD+C] on OS X to copy text.
    li #[kbd CTRL+X] on Windows/Linux or #[kbd CMD+X] on OS X to cut text.
    li #[kbd CTRL+V] on Windows/Linux or #[kbd CMD+V] on OS X to paste text.
    li #[kbd CTRL+Z] on Windows/Linux or #[kbd CMD+Z] on OS X to undo changes.
    li #[kbd CTRL+Y] on Windows/Linux or #[kbd CMD+SHIFT+Z] on OS X to redo changes that were undone.
    li #[kbd SHIFT+Delete] to delete an entire line.

  blockquote The displaying of the Dev Zone may be toggled at any time by hitting #[kbd CTRL+SHIFT+E] on Windows/Linux or #[kbd CMD+OPT+E] on OS X

  img(alt="screenshot", title="VR Editor Layout", src="images/editorVR/layout" + jpgExt)

  h3 Documentation Window

  p To the left of the Code Editor is the Documentation Window. For now, it's a static, read-only listing of the scripting functions that are available for using in the Code Editor. Eventually, it will become a live-query-able terminal for all of the documentation within Primrose.

  img(alt="screenshot", title="Documentation Window", src="images/editorVR/docWindow" + jpgExt)

  h3 Console Window

  p To the right of the Code Editor is the Console Window. For now, it's a static, read-only printing from whenever you call the #[code log()] function with a String parameter in the Code Editor, as well as a description of any errors that occurred during script execution. Eventually, it will become a live-executable terminal for both logging and REPL code execution, exactly the same as the JavaScript Console in your browser's Developer Tools view.

  img(alt="screenshot", title="Documentation Window", src="images/editorVR/consoleWindow" + jpgExt)

  h2 Selection Sphere

  p At the center of your view is a small sphere. This is your cursor--we call it the "Selection Sphere". It will follow your mouse, or--if you are not using a mouse--it will follow your head movements as you look around. The Selection Sphere performs different actions when activated in different contexts.

  p There are several ways to activate the Selection Sphere:
  ul
    li clicking the #[kbd left mouse button],
    li tapping anywhere on the screen,
    li depressing the bumper on your Google Cardboard,
    li tapping the #[kbd A] button on your Xbox 360 controller, or
    li hitting the #[kbd Enter] key on your keyboard.

  h3 Navigating with the Selection Sphere
  p When you point the Selection Sphere to the ground, it turns white and grows in size. Activating the Selection Sphere will make you jump to that position. Additionally, if you are currently in Editing Mode, activating the Selection Sphere while pointing at the ground will switch you to Navigation Mode.

  blockquote Experience has shown that "blink" style movement between locations is the most reliable for avoiding nausea for people prone to simulator sickness while using a VR headset.

  p There are a few additional ways to navigate the environment:
  ul
    li #[kbd WASD] keys on the keyboard, a common system from First Person Shooter video games,
    li #[kbd Arrow-keys] on the keyboard, a simple fallback for #[kbd WASD] both for people who prefer arrow keys and supporting the #[a(href="http://store.steampowered.com/app/353370/") Steam Controller],
    li #[kbd left analog stick] on your Xbox 360 gamepad.

  img(alt="screenshot", title="Cursor Sphere", src="images/editorVR/cursor1" + jpgExt)

  h3 Making Text Selections with the Selection Sphere
  p When you point the Selection Sphere at a text area, it turns white and shrinks in size. If you are currently in Navigation Mode, activating the Selection Sphere will switch you to Editing Mode.

  p Once in Editing Mode, depressing a button to begin activating the Selection Sphere will move the text cursor to that location and begin a text selection.

  img(alt="screenshot", title="Cursor Sphere", src="images/editorVR/cursor2" + jpgExt)

  p You may then move the Selection Sphere, dragging out a text selection. Releasing the button to activate the Selection Sphere will set the end of the text selection.

  img(alt="screenshot", title="Cursor Sphere", src="images/editorVR/cursor3" + jpgExt)

  h3 Canceling Edit Mode without Navigating
  p If there is no object under the Selection Sphere, it will turn red and shrink in size. If you are currently in Editing Mode, activating the Selection Sphere at this point will put you in Navigation Mode. If you are already in Navigation Mode, activating the Selection Sphere will have no effect.

  img(alt="screenshot", title="Cursor Sphere", src="images/editorVR/cursor4" + jpgExt)

  h2 Scripting

  p The Code Editor window will have a demo script loaded in it at first. When you edit code, Primrose will wait for you to stop typing for a second and then run your script automatically. In the background, Primrose is inserting the code you write inside of a function. That function provides a clean workspace for you to write your code, so that any variables you create won't clobber the values defined outside of your script.

  h3 Setup and Animation

  p The layout of your script is very simple. At the top level, you can create any variables you want. Use this section as your one-time setup for your script. Create whatever Three.js objects you want, and add them to your scene.

  p At the end, you return a function that Primrose can use to update and animate your scene. That function will receive a single parameter #[code dt], which is the amount of time in milliseconds that has elapsed since the last time the update function ran.

  p In other words:
  pre: code.
      grammar("JavaScript");
      // perform setup here
      var myBlock = put( brick( ROCK ) )
        .on( scene )
        .at( 0, 0, 0 )
        .obj();

      // Then, return an update function so Primrose knows what to do for you
      // every frame
      var t = 0;
      return function(dt){
        t += dt;
        myBlock.position.x = Math.cos( t );
        myBlock.position.z = Math.sin( t );
      }

  p The code that is currently running in the example demo is:
  pre: code.
      grammar("JavaScript");
      var WIDTH = 5,
          HEIGHT = 5,
          DEPTH = 5
          MIDX = WIDTH / 2,
          MIDY = HEIGHT / 2, MIDZ = DEPTH / 2,
          t = 0,
          start = put( hub() )
          .on( scene )
          .at( -MIDX, 0, -DEPTH - 2 )
          .obj();

      put( light( 0xffffff, 1, 500 ) )
          .on( start )
          .at( MIDX + 5, 8, MIDZ + 20 );

      var balls = [ ];

      for ( var i = 0; i &lt; 10; ++i ) {
        balls.push( put( brick( WATER ) )
            .on( start )
            .at( Primrose.Random.int( WIDTH ),
                Primrose.Random.int( HEIGHT ),
                Primrose.Random.int( DEPTH ) )
            .obj() );

        balls[i].velocity = v3(
            Primrose.Random.number( 0, WIDTH ),
            Primrose.Random.number( 0, HEIGHT ),
            Primrose.Random.number( 0, DEPTH ) );
      }

      function update ( dt ) {
        t += dt;
        for ( var i = 0; i &lt; balls.length; ++i ) {
          var ball = balls[i];
          ball.position.add( ball.velocity.clone().multiplyScalar( dt ) );
          if ( ball.position.x &lt; 0 && ball.velocity.x &lt; 0
              || WIDTH &lt;= ball.position.x && ball.velocity.x > 0 ) {
            ball.velocity.x *= -1;
          }
          if ( ball.position.y &lt; 1 && ball.velocity.y &lt; 0
              || HEIGHT &lt;= ball.position.y && ball.velocity.y > 0 ) {
            ball.velocity.y *= -1;
          }
          if ( ball.position.z &lt; 0 && ball.velocity.z &lt; 0
              || DEPTH &lt;= ball.position.z && ball.velocity.z > 0 ) {
            ball.velocity.z *= -1;
          }
        }
      }

  h3 Scripting Functions

  p There are a few helper functions that are available while interactively building scripts. They are shortly-named functions for common operations to make them easy to type in the editor. The functions are grouped into a few separate purposes:

  ul
    li
      | 3D Scene Objects. These objects can be added to a scene right away.
      ul
        li #[a(href="#axis") #[code axis(length, width)]] - create a set of axis bars, red for X, green for Y, blue for Z. Length is how long each bar should be in its own axis. Width is how large each bar should be in the other axes.
        li #[a(href="#brick") #[code brick(txt, w, h, l)]] - create a textured block of a certain size.
        li #[a(href="#cloud") #[code cloud(verts, color, size)]] - create a point-cloud
        li #[a(href="#hub") #[code hub()]] - create a node in the scene graph in which you can group other objects.
        li #[a(href="#light") #[code light(color, [intensity, [distance, [decay]]])]] - create a light
    li
      | Geometries in need of texturing. The objects need to be bound with a material on a 3D object before they can be used in the scene.
      ul
        li #[a(href="#box") #[code box(width, height, length)]] - short-cut function for creating a THREE.BoxGeometry object.
        li #[a(href="#cylinder") #[code cylinder(radiusTop, radiusBottom, height, rS, hS, openEnded, thetaStart, thetaEnd)]] - short-cut function for creating a THREE.CylinderGeometry object.
        li #[a(href="#quad") #[code quad(width, height, s, t)]] - create a single rectangle.
        li #[a(href="#shell") #[code shell(r, slices, rings, phi, theta)]] - create a section of an inside-out sphere.
        li #[a(href="#sphere") #[code sphere(r, slices, rings)]] - short-cut function for creating a THREE.BufferedSphereGeometry object.
    li
      | Other utility functions.
      ul
        li #[a(href="#fmt") #[code fmt(template, arg1, arg2, ...)]] - string formatting.
        li #[a(href="#log") #[code log(str)]] - write out debugging output to the console.
        li #[a(href="#put") #[code put(obj).on(obj).at(x, y, z)]] - combine objects and space them apart.
        li #[a(href="#range") #[code range(min, max, step, thunk)]] - call a function a certain number of times.
        li #[a(href="#textured") #[code textured(geometry, txt, unshaded, opacity, s, t)]] - apply a texture to a geometry.
        li #[a(href="#v3") #[code v3(x, y, z)]] - short-cut function for creating a THREE.Vector3 object.

  h3 User Input

  p To be able to listen for user input, you create event listeners attached to the #[a(href="#Primrose_BrowserEnvironment") #[code BrowserEnvironment]] object named #[code this] in the context of your script. To setup event listeners, in your script's setup header, call #[code this.addEventListener("&lt;eventName>", callbackFunction)].

  p Currently, the available events are:
  ul
    li #[a(href="#Primrose_BrowserEnvironment__keydown") #[code keydown]] - a key is depressed on the keyboard.
    li #[a(href="#Primrose_BrowserEnvironment__keyup") #[code keyup]] - a depressed key is released on the keyboard.
    li #[a(href="#Primrose_BrowserEnvironment__keypress") #[code keypress]] - a key is depressed and released on the keyboard.
    li #[a(href="#Primrose_BrowserEnvironment__wheel") #[code wheel]] - the user rolls the mouse wheel.
    li #[a(href="#Primrose_BrowserEnvironment__mousedown") #[code mousedown]] - a button is depressed on the mouse.
    li #[a(href="#Primrose_BrowserEnvironment__mouseup") #[code mouseup]] - a depressed button is released on the mouse.
    li #[a(href="#Primrose_BrowserEnvironment__mousemove") #[code mousemove]] - the mouse is moved.
    li #[a(href="#Primrose_BrowserEnvironment__touchstart") #[code touchstart]] - a finger touches down on a touch screen.
    li #[a(href="#Primrose_BrowserEnvironment__touchend") #[code touchend]] - a finger touching the touch screen is removed.
    li #[a(href="#Primrose_BrowserEnvironment__touchmove") #[code touchmove]] - a finger is slid across the screen.
    li #[a(href="#Primrose_BrowserEnvironment__pointerstart") #[code pointerstart]] - either a #[code touchstart] or a #[code mousedown] occurs.
    li #[a(href="#Primrose_BrowserEnvironment__pointermove") #[code pointermove]] - either a #[code touchend] or #[code mouseup] occurs.
    li #[a(href="#Primrose_BrowserEnvironment__pointerend") #[code pointerend]] - either a #[code touchmove] or #[code mousemove] occurs.
    li #[a(href="#Primrose_BrowserEnvironment__gazestart") #[code gazestart]] - occurs when the central Selection Sphere hovers over an object, inferring the user started looking at that object.
    li #[a(href="#Primrose_BrowserEnvironment__gazecomplete") #[code gazecomplete]] - occurs if the Selection Sphere does not leave the object it hit in #[code gazestart] before the #[a(href="#Primrose_BrowserEnvironment_DEFAULTS_gazeLength") #[code gazeLength]] expires (default 1s).
    li #[a(href="#Primrose_BrowserEnvironment__gazecancel") #[code gazecancel]] - occurs if the Selection Sphere leaves the object it hit in #[code gazestart] before the #[a(href="#Primrose_BrowserEnvironment_DEFAULTS_gazeLength") #[code gazeLength]] expires (default 1s).
